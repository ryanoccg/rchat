<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;
use App\Traits\BelongsToCompany;

class Media extends Model
{
    use HasFactory, SoftDeletes, BelongsToCompany;

    protected $fillable = [
        'company_id',
        'file_name',
        'file_type',
        'mime_type',
        'extension',
        'file_size',
        'disk',
        'path',
        'url',
        'thumbnail_url',
        'media_type',
        'collection',
        'folder_path',
        'metadata',
        'custom_properties',
        'conversions',
        'mediable_type',
        'mediable_id',
        'mediable_order',
        'alt',
        'title',
        'description',
        'caption',
        'ai_analysis',
        'ai_tags',
        'ai_embeddings',
        'usage_count',
        'last_used_at',
        'uploaded_by',
        'source',
        'source_url',
    ];

    protected $casts = [
        'metadata' => 'array',
        'custom_properties' => 'array',
        'conversions' => 'array',
        'ai_tags' => 'array',
        'ai_embeddings' => 'array',
        'file_size' => 'integer',
        'usage_count' => 'integer',
        'mediable_order' => 'integer',
        'last_used_at' => 'datetime',
    ];

    /**
     * Media type constants
     */
    public const TYPE_IMAGE = 'image';
    public const TYPE_VIDEO = 'video';
    public const TYPE_AUDIO = 'audio';
    public const TYPE_DOCUMENT = 'document';
    public const TYPE_FILE = 'file';

    /**
     * Source constants
     */
    public const SOURCE_DIRECT = 'direct';       // Uploaded by user
    public const SOURCE_PLATFORM = 'platform';   // From messaging platform
    public const SOURCE_IMPORT = 'import';       // Imported from URL/file
    public const SOURCE_AI_GENERATED = 'ai_generated'; // Generated by AI

    /**
     * Get the company that owns the media
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    /**
     * Get the user who uploaded the media
     */
    public function uploader(): BelongsTo
    {
        return $this->belongsTo(User::class, 'uploaded_by');
    }

    /**
     * Get the parent mediable model
     */
    public function mediable(): MorphTo
    {
        return $this->morphTo();
    }

    /**
     * Scope to filter by media type
     */
    public function scopeOfType($query, string $type)
    {
        return $query->where('media_type', $type);
    }

    /**
     * Scope to filter by collection
     */
    public function scopeInCollection($query, string $collection)
    {
        return $query->where('collection', $collection);
    }

    /**
     * Scope to filter by folder
     */
    public function scopeInFolder($query, ?string $folder)
    {
        if ($folder === null || $folder === '') {
            return $query->whereNull('folder_path')->orWhere('folder_path', '');
        }
        return $query->where('folder_path', $folder);
    }

    /**
     * Scope to get images only
     */
    public function scopeImages($query)
    {
        return $query->where('media_type', self::TYPE_IMAGE);
    }

    /**
     * Scope to get videos only
     */
    public function scopeVideos($query)
    {
        return $query->where('media_type', self::TYPE_VIDEO);
    }

    /**
     * Scope to get audio only
     */
    public function scopeAudio($query)
    {
        return $query->where('media_type', self::TYPE_AUDIO);
    }

    /**
     * Scope to get documents only
     */
    public function scopeDocuments($query)
    {
        return $query->where('media_type', self::TYPE_DOCUMENT);
    }

    /**
     * Scope to search by file name
     */
    public function scopeSearch($query, string $term)
    {
        return $query->where(function ($q) use ($term) {
            $q->where('file_name', 'like', "%{$term}%")
                ->orWhere('alt', 'like', "%{$term}%")
                ->orWhere('title', 'like', "%{$term}%")
                ->orWhere('description', 'like', "%{$term}%");
        });
    }

    /**
     * Scope to get unused media
     */
    public function scopeUnused($query, int $days = 30)
    {
        return $query->where(function ($q) use ($days) {
            $q->whereNull('last_used_at')
                ->orWhere('last_used_at', '<', now()->subDays($days));
        });
    }

    /**
     * Check if this is an image
     */
    public function isImage(): bool
    {
        return $this->media_type === self::TYPE_IMAGE;
    }

    /**
     * Check if this is a video
     */
    public function isVideo(): bool
    {
        return $this->media_type === self::TYPE_VIDEO;
    }

    /**
     * Check if this is an audio file
     */
    public function isAudio(): bool
    {
        return $this->media_type === self::TYPE_AUDIO;
    }

    /**
     * Check if this is a document
     */
    public function isDocument(): bool
    {
        return $this->media_type === self::TYPE_DOCUMENT;
    }

    /**
     * Check if this is viewable in browser
     */
    public function isViewable(): bool
    {
        return in_array($this->media_type, [self::TYPE_IMAGE, self::TYPE_VIDEO, self::TYPE_AUDIO]);
    }

    /**
     * Get the file size in human readable format
     */
    public function getHumanSize(): string
    {
        $bytes = $this->file_size;
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];

        for ($i = 0; $bytes > 1024; $i++) {
            $bytes /= 1024;
        }

        return round($bytes, 2) . ' ' . $units[$i];
    }

    /**
     * Get the full URL (with thumbnail fallback for images)
     */
    public function getFullUrl(): string
    {
        if ($this->isImage() && $this->thumbnail_url) {
            return $this->thumbnail_url;
        }
        return $this->url;
    }

    /**
     * Get the dimensions from metadata (for images/videos)
     */
    public function getWidth(): ?int
    {
        return $this->metadata['width'] ?? null;
    }

    /**
     * Get the height from metadata (for images/videos)
     */
    public function getHeight(): ?int
    {
        return $this->metadata['height'] ?? null;
    }

    /**
     * Get the duration from metadata (for audio/video)
     */
    public function getDuration(): ?int
    {
        return $this->metadata['duration'] ?? null;
    }

    /**
     * Increment usage count and update last used timestamp
     */
    public function markAsUsed(): void
    {
        $this->increment('usage_count');
        $this->update(['last_used_at' => now()]);
    }

    /**
     * Get a specific custom property
     */
    public function getCustomProperty(string $key, mixed $default = null): mixed
    {
        return data_get($this->custom_properties, $key, $default);
    }

    /**
     * Set a custom property
     */
    public function setCustomProperty(string $key, mixed $value): void
    {
        $properties = $this->custom_properties ?? [];
        data_set($properties, $key, $value);
        $this->custom_properties = $properties;
    }

    /**
     * Get media type from MIME type
     */
    public static function getMediaTypeFromMime(string $mimeType): string
    {
        return match (true) {
            str_starts_with($mimeType, 'image/') => self::TYPE_IMAGE,
            str_starts_with($mimeType, 'video/') => self::TYPE_VIDEO,
            str_starts_with($mimeType, 'audio/') => self::TYPE_AUDIO,
            in_array($mimeType, [
                'application/pdf',
                'application/msword',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'application/vnd.ms-excel',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'application/vnd.ms-powerpoint',
                'application/vnd.openxmlformats-officedocument.presentationml.presentation',
                'text/plain',
                'text/csv',
            ]) => self::TYPE_DOCUMENT,
            default => self::TYPE_FILE,
        };
    }

    /**
     * Get file type from MIME type (more specific category)
     */
    public static function getFileTypeFromMime(string $mimeType): string
    {
        return match ($mimeType) {
            // Images
            'image/jpeg', 'image/jpg' => 'jpeg',
            'image/png' => 'png',
            'image/gif' => 'gif',
            'image/webp' => 'webp',
            'image/svg+xml' => 'svg',
            'image/avif' => 'avif',

            // Videos
            'video/mp4' => 'mp4',
            'video/webm' => 'webm',
            'video/ogg' => 'ogv',
            'video/quicktime' => 'mov',

            // Audio
            'audio/mpeg', 'audio/mp3' => 'mp3',
            'audio/wav' => 'wav',
            'audio/ogg' => 'ogg',
            'audio/webm' => 'weba',
            'audio/m4a', 'audio/x-m4a' => 'm4a',
            'audio/aac' => 'aac',

            // Documents
            'application/pdf' => 'pdf',
            'application/msword' => 'doc',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document' => 'docx',
            'application/vnd.ms-excel' => 'xls',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' => 'xlsx',
            'application/vnd.ms-powerpoint' => 'ppt',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation' => 'pptx',
            'text/plain' => 'txt',
            'text/csv' => 'csv',
            'application/zip' => 'zip',
            'application/x-rar-compressed' => 'rar',

            default => 'file',
        };
    }

    /**
     * Get extension from MIME type
     */
    public static function getExtensionFromMime(string $mimeType): string
    {
        $extensions = [
            'image/jpeg' => 'jpg',
            'image/png' => 'png',
            'image/gif' => 'gif',
            'image/webp' => 'webp',
            'image/svg+xml' => 'svg',
            'image/avif' => 'avif',
            'video/mp4' => 'mp4',
            'video/webm' => 'webm',
            'video/ogg' => 'ogv',
            'video/quicktime' => 'mov',
            'audio/mpeg' => 'mp3',
            'audio/wav' => 'wav',
            'audio/ogg' => 'ogg',
            'audio/webm' => 'weba',
            'audio/m4a' => 'm4a',
            'audio/aac' => 'aac',
            'application/pdf' => 'pdf',
            'application/msword' => 'doc',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document' => 'docx',
            'application/vnd.ms-excel' => 'xls',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' => 'xlsx',
            'application/vnd.ms-powerpoint' => 'ppt',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation' => 'pptx',
            'text/plain' => 'txt',
            'text/csv' => 'csv',
            'application/zip' => 'zip',
        ];

        return $extensions[$mimeType] ?? 'bin';
    }

    /**
     * Get the icon for the media type
     */
    public function getIcon(): string
    {
        return match ($this->media_type) {
            self::TYPE_IMAGE => 'pi pi-image',
            self::TYPE_VIDEO => 'pi pi-video',
            self::TYPE_AUDIO => 'pi pi-volume-up',
            self::TYPE_DOCUMENT => 'pi pi-file',
            default => 'pi pi-file',
        };
    }
}
